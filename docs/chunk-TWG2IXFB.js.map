{
  "version": 3,
  "sources": ["src/app/shared/service/services/page-time-tracker.service.ts", "src/app/features/onboarding/onboarding.service.ts"],
  "sourcesContent": ["import { Injectable } from '@angular/core';\n\n/**\n * Service for tracking active time spent on specific pages.\n * Tracks only when the tab is active and visible to the user.\n */\n@Injectable({\n  providedIn: 'root'\n})\nexport class PageTimeTrackerService {\n  private _trackers = new Map<string, {\n    startTime?: number;\n    totalTime: number;\n    isActive: boolean;\n    requiredTime: number;\n    onComplete?: () => void;\n    visibilityHandler?: () => void;\n    cleanupTimeout?: number;\n  }>();\n\n  /**\n   * Start tracking time for a specific page\n   * @param pageKey - Unique identifier for the page\n   * @param requiredTimeMs - Required time in milliseconds to consider complete\n   * @param onComplete - Callback function when required time is reached\n   */\n  startTracking(pageKey: string, requiredTimeMs: number, onComplete?: () => void): void {\n    // Don't start if already completed\n    if (this.isCompleted(pageKey)) {\n      return;\n    }\n\n    const existingTracker = this._trackers.get(pageKey);\n    \n    // If tracker exists and is active, don't restart\n    if (existingTracker?.isActive) {\n      return;\n    }\n\n    const tracker = {\n      startTime: Date.now(),\n      totalTime: existingTracker?.totalTime || 0,\n      isActive: true,\n      requiredTime: requiredTimeMs,\n      onComplete\n    };\n\n    this._trackers.set(pageKey, tracker);\n    this._setupVisibilityTracking(pageKey);\n  }\n\n  /**\n   * Stop tracking time for a specific page\n   * @param pageKey - Unique identifier for the page\n   */\n  stopTracking(pageKey: string): void {\n    const tracker = this._trackers.get(pageKey);\n    \n    if (!tracker || !tracker.isActive) {\n      return;\n    }\n\n    // Add session time to total\n    if (tracker.startTime) {\n      const sessionTime = Date.now() - tracker.startTime;\n      tracker.totalTime += sessionTime;\n    }\n\n    tracker.isActive = false;\n    tracker.startTime = undefined;\n\n    // Check if completed\n    if (tracker.totalTime >= tracker.requiredTime && tracker.onComplete) {\n      tracker.onComplete();\n    }\n\n    // Cleanup visibility handler\n    this._cleanupVisibilityHandler(pageKey);\n  }\n\n  /**\n   * Check if the required time has been reached for a page\n   * @param pageKey - Unique identifier for the page\n   * @returns true if required time has been reached\n   */\n  isCompleted(pageKey: string): boolean {\n    const tracker = this._trackers.get(pageKey);\n    return tracker ? tracker.totalTime >= tracker.requiredTime : false;\n  }\n\n  /**\n   * Get current progress (0-1) for a page\n   * @param pageKey - Unique identifier for the page\n   * @returns progress as a number between 0 and 1\n   */\n  getProgress(pageKey: string): number {\n    const tracker = this._trackers.get(pageKey);\n    if (!tracker) return 0;\n    \n    let currentTotal = tracker.totalTime;\n    \n    // Add current session time if active\n    if (tracker.isActive && tracker.startTime) {\n      currentTotal += Date.now() - tracker.startTime;\n    }\n    \n    return Math.min(currentTotal / tracker.requiredTime, 1);\n  }\n\n  /**\n   * Get total time spent on a page in milliseconds\n   * @param pageKey - Unique identifier for the page\n   * @returns total time in milliseconds\n   */\n  getTotalTime(pageKey: string): number {\n    const tracker = this._trackers.get(pageKey);\n    if (!tracker) return 0;\n    \n    let currentTotal = tracker.totalTime;\n    \n    // Add current session time if active\n    if (tracker.isActive && tracker.startTime) {\n      currentTotal += Date.now() - tracker.startTime;\n    }\n    \n    return currentTotal;\n  }\n\n  /**\n   * Reset tracking data for a specific page\n   * @param pageKey - Unique identifier for the page\n   */\n  resetTracking(pageKey: string): void {\n    const tracker = this._trackers.get(pageKey);\n    \n    if (tracker) {\n      this._cleanupVisibilityHandler(pageKey);\n      this._trackers.delete(pageKey);\n    }\n  }\n\n  /**\n   * Reset all tracking data\n   */\n  resetAllTracking(): void {\n    for (const [pageKey] of this._trackers) {\n      this.resetTracking(pageKey);\n    }\n  }\n\n  private _setupVisibilityTracking(pageKey: string): void {\n    const tracker = this._trackers.get(pageKey);\n    if (!tracker) return;\n\n    const handleVisibilityChange = () => {\n      const currentTracker = this._trackers.get(pageKey);\n      if (!currentTracker?.isActive) return;\n\n      if (document.hidden) {\n        // Tab became inactive - pause tracking\n        if (currentTracker.startTime) {\n          const sessionTime = Date.now() - currentTracker.startTime;\n          currentTracker.totalTime += sessionTime;\n          currentTracker.startTime = undefined;\n        }\n      } else {\n        // Tab became active - resume tracking\n        currentTracker.startTime = Date.now();\n      }\n\n      // Check if completed after visibility change\n      if (currentTracker.totalTime >= currentTracker.requiredTime && currentTracker.onComplete) {\n        currentTracker.onComplete();\n      }\n    };\n\n    // Store the handler for cleanup\n    tracker.visibilityHandler = handleVisibilityChange;\n    document.addEventListener('visibilitychange', handleVisibilityChange);\n\n    // Auto-cleanup after 10 minutes to prevent memory leaks\n    tracker.cleanupTimeout = window.setTimeout(() => {\n      this._cleanupVisibilityHandler(pageKey);\n    }, 600000);\n  }\n\n  private _cleanupVisibilityHandler(pageKey: string): void {\n    const tracker = this._trackers.get(pageKey);\n    \n    if (tracker?.visibilityHandler) {\n      document.removeEventListener('visibilitychange', tracker.visibilityHandler);\n      tracker.visibilityHandler = undefined;\n    }\n\n    if (tracker?.cleanupTimeout) {\n      clearTimeout(tracker.cleanupTimeout);\n      tracker.cleanupTimeout = undefined;\n    }\n  }\n}\n", "import { Injectable, signal, computed, inject } from '@angular/core';\nimport { PageTimeTrackerService } from '../../shared/service/services/page-time-tracker.service';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class OnboardingService {\n  private _pageTimeTracker = inject(PageTimeTrackerService);\n  private static readonly FAQ_PAGE_KEY = 'onboarding_faq';\n  private static readonly FAQ_REQUIRED_TIME = 120000; // 2 minutes\n  // Сигналы для хранения состояния шагов\n  private _settingsDone = signal(!!localStorage.getItem('onboarding_settings_done'));\n  private _productDone = signal(!!localStorage.getItem('onboarding_product_done'));\n  private _recipeDone = signal(!!localStorage.getItem('onboarding_recipe_done'));\n  private _faqDone = signal(!!localStorage.getItem('onboarding_faq_done'));\n\n  // Computed для общего статуса\n  isOnboardingComplete = computed(() =>\n    this._settingsDone() && this._productDone() && this._recipeDone() && this._faqDone()\n  );\n\n  markProductDone() {\n    localStorage.setItem('onboarding_product_done', '1');\n    this._productDone.set(true);\n  }\n\n  markRecipeDone() {\n    localStorage.setItem('onboarding_recipe_done', '1');\n    this._recipeDone.set(true);\n  }\n\n  markSettingsDone() {\n    localStorage.setItem('onboarding_settings_done', '1');\n    this._settingsDone.set(true);\n  }\n\n  markFaqDone() {\n    localStorage.setItem('onboarding_faq_done', '1');\n    this._faqDone.set(true);\n  }\n\n  private _onFaqCompleted = () => {\n    this.markFaqDone();\n  };\n\n  isProductDone(): boolean {\n    return this._productDone();\n  }\n\n  isRecipeDone(): boolean {\n    return this._recipeDone();\n  }\n\n  isSettingsDone(): boolean {\n    return this._settingsDone();\n  }\n\n  isFaqDone(): boolean {\n    return this._faqDone();\n  }\n}\n"],
  "mappings": ";;;;;;;;;;AASM,IAAO,yBAAP,MAAO,wBAAsB;EACzB,YAAY,oBAAI,IAAG;;;;;;;EAgB3B,cAAc,SAAiB,gBAAwB,YAAuB;AAE5E,QAAI,KAAK,YAAY,OAAO,GAAG;AAC7B;IACF;AAEA,UAAM,kBAAkB,KAAK,UAAU,IAAI,OAAO;AAGlD,QAAI,iBAAiB,UAAU;AAC7B;IACF;AAEA,UAAM,UAAU;MACd,WAAW,KAAK,IAAG;MACnB,WAAW,iBAAiB,aAAa;MACzC,UAAU;MACV,cAAc;MACd;;AAGF,SAAK,UAAU,IAAI,SAAS,OAAO;AACnC,SAAK,yBAAyB,OAAO;EACvC;;;;;EAMA,aAAa,SAAe;AAC1B,UAAM,UAAU,KAAK,UAAU,IAAI,OAAO;AAE1C,QAAI,CAAC,WAAW,CAAC,QAAQ,UAAU;AACjC;IACF;AAGA,QAAI,QAAQ,WAAW;AACrB,YAAM,cAAc,KAAK,IAAG,IAAK,QAAQ;AACzC,cAAQ,aAAa;IACvB;AAEA,YAAQ,WAAW;AACnB,YAAQ,YAAY;AAGpB,QAAI,QAAQ,aAAa,QAAQ,gBAAgB,QAAQ,YAAY;AACnE,cAAQ,WAAU;IACpB;AAGA,SAAK,0BAA0B,OAAO;EACxC;;;;;;EAOA,YAAY,SAAe;AACzB,UAAM,UAAU,KAAK,UAAU,IAAI,OAAO;AAC1C,WAAO,UAAU,QAAQ,aAAa,QAAQ,eAAe;EAC/D;;;;;;EAOA,YAAY,SAAe;AACzB,UAAM,UAAU,KAAK,UAAU,IAAI,OAAO;AAC1C,QAAI,CAAC;AAAS,aAAO;AAErB,QAAI,eAAe,QAAQ;AAG3B,QAAI,QAAQ,YAAY,QAAQ,WAAW;AACzC,sBAAgB,KAAK,IAAG,IAAK,QAAQ;IACvC;AAEA,WAAO,KAAK,IAAI,eAAe,QAAQ,cAAc,CAAC;EACxD;;;;;;EAOA,aAAa,SAAe;AAC1B,UAAM,UAAU,KAAK,UAAU,IAAI,OAAO;AAC1C,QAAI,CAAC;AAAS,aAAO;AAErB,QAAI,eAAe,QAAQ;AAG3B,QAAI,QAAQ,YAAY,QAAQ,WAAW;AACzC,sBAAgB,KAAK,IAAG,IAAK,QAAQ;IACvC;AAEA,WAAO;EACT;;;;;EAMA,cAAc,SAAe;AAC3B,UAAM,UAAU,KAAK,UAAU,IAAI,OAAO;AAE1C,QAAI,SAAS;AACX,WAAK,0BAA0B,OAAO;AACtC,WAAK,UAAU,OAAO,OAAO;IAC/B;EACF;;;;EAKA,mBAAgB;AACd,eAAW,CAAC,OAAO,KAAK,KAAK,WAAW;AACtC,WAAK,cAAc,OAAO;IAC5B;EACF;EAEQ,yBAAyB,SAAe;AAC9C,UAAM,UAAU,KAAK,UAAU,IAAI,OAAO;AAC1C,QAAI,CAAC;AAAS;AAEd,UAAM,yBAAyB,MAAK;AAClC,YAAM,iBAAiB,KAAK,UAAU,IAAI,OAAO;AACjD,UAAI,CAAC,gBAAgB;AAAU;AAE/B,UAAI,SAAS,QAAQ;AAEnB,YAAI,eAAe,WAAW;AAC5B,gBAAM,cAAc,KAAK,IAAG,IAAK,eAAe;AAChD,yBAAe,aAAa;AAC5B,yBAAe,YAAY;QAC7B;MACF,OAAO;AAEL,uBAAe,YAAY,KAAK,IAAG;MACrC;AAGA,UAAI,eAAe,aAAa,eAAe,gBAAgB,eAAe,YAAY;AACxF,uBAAe,WAAU;MAC3B;IACF;AAGA,YAAQ,oBAAoB;AAC5B,aAAS,iBAAiB,oBAAoB,sBAAsB;AAGpE,YAAQ,iBAAiB,OAAO,WAAW,MAAK;AAC9C,WAAK,0BAA0B,OAAO;IACxC,GAAG,GAAM;EACX;EAEQ,0BAA0B,SAAe;AAC/C,UAAM,UAAU,KAAK,UAAU,IAAI,OAAO;AAE1C,QAAI,SAAS,mBAAmB;AAC9B,eAAS,oBAAoB,oBAAoB,QAAQ,iBAAiB;AAC1E,cAAQ,oBAAoB;IAC9B;AAEA,QAAI,SAAS,gBAAgB;AAC3B,mBAAa,QAAQ,cAAc;AACnC,cAAQ,iBAAiB;IAC3B;EACF;;qCA7LW,yBAAsB;EAAA;4EAAtB,yBAAsB,SAAtB,wBAAsB,WAAA,YAFrB,OAAM,CAAA;;;sEAEP,wBAAsB,CAAA;UAHlC;WAAW;MACV,YAAY;KACb;;;;;ACFK,IAAO,oBAAP,MAAO,mBAAiB;EACpB,mBAAmB,OAAO,sBAAsB;EAChD,OAAgB,eAAe;EAC/B,OAAgB,oBAAoB;;;EAEpC,gBAAgB,OAAO,CAAC,CAAC,aAAa,QAAQ,0BAA0B,GAAC,GAAA,YAAA,CAAA,EAAA,WAAA,gBAAA,CAAA,IAAA,CAAA,CAAA;EACzE,eAAe,OAAO,CAAC,CAAC,aAAa,QAAQ,yBAAyB,GAAC,GAAA,YAAA,CAAA,EAAA,WAAA,eAAA,CAAA,IAAA,CAAA,CAAA;EACvE,cAAc,OAAO,CAAC,CAAC,aAAa,QAAQ,wBAAwB,GAAC,GAAA,YAAA,CAAA,EAAA,WAAA,cAAA,CAAA,IAAA,CAAA,CAAA;EACrE,WAAW,OAAO,CAAC,CAAC,aAAa,QAAQ,qBAAqB,GAAC,GAAA,YAAA,CAAA,EAAA,WAAA,WAAA,CAAA,IAAA,CAAA,CAAA;;EAGvE,uBAAuB,SAAS,MAC9B,KAAK,cAAa,KAAM,KAAK,aAAY,KAAM,KAAK,YAAW,KAAM,KAAK,SAAQ,GAAE,GAAA,YAAA,CAAA,EAAA,WAAA,uBAAA,CAAA,IAAA,CAAA,CAAA;EAGtF,kBAAe;AACb,iBAAa,QAAQ,2BAA2B,GAAG;AACnD,SAAK,aAAa,IAAI,IAAI;EAC5B;EAEA,iBAAc;AACZ,iBAAa,QAAQ,0BAA0B,GAAG;AAClD,SAAK,YAAY,IAAI,IAAI;EAC3B;EAEA,mBAAgB;AACd,iBAAa,QAAQ,4BAA4B,GAAG;AACpD,SAAK,cAAc,IAAI,IAAI;EAC7B;EAEA,cAAW;AACT,iBAAa,QAAQ,uBAAuB,GAAG;AAC/C,SAAK,SAAS,IAAI,IAAI;EACxB;EAEQ,kBAAkB,MAAK;AAC7B,SAAK,YAAW;EAClB;EAEA,gBAAa;AACX,WAAO,KAAK,aAAY;EAC1B;EAEA,eAAY;AACV,WAAO,KAAK,YAAW;EACzB;EAEA,iBAAc;AACZ,WAAO,KAAK,cAAa;EAC3B;EAEA,YAAS;AACP,WAAO,KAAK,SAAQ;EACtB;;qCArDW,oBAAiB;EAAA;4EAAjB,oBAAiB,SAAjB,mBAAiB,WAAA,YAFhB,OAAM,CAAA;;;sEAEP,mBAAiB,CAAA;UAH7B;WAAW;MACV,YAAY;KACb;;;",
  "names": []
}
